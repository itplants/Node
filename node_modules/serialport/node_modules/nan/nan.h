/*********************************************************************
 * NAN - Native Abstractions for Node.js
 *
 * Copyright (c) 2015 NAN contributors:
 *   - Rod Vagg <https://github.com/rvagg>
 *   - Benjamin Byholm <https://github.com/kkoopa>
 *   - Trevor Norris <https://github.com/trevnorris>
 *   - Nathan Rajlich <https://github.com/TooTallNate>
 *   - Brett Lawson <https://github.com/brett19>
 *   - Ben Noordhuis <https://github.com/bnoordhuis>
 *   - David Siegel <https://github.com/agnat>
 *
 * MIT License <https://github.com/rvagg/nan/blob/master/LICENSE.md>
 *
 * Version 1.8.4: current Node 12: 0.12.2, Node 10: 0.10.38, io.js: 1.8.1
 *
 * See https://github.com/rvagg/nan for the latest update to this file
 **********************************************************************************/

#ifndef NAN_H_
#define NAN_H_

#include <uv.h>
#include <node.h>
#include <node_buffer.h>
#include <node_version.h>
#include <node_object_wrap.h>
#include <cstring>
#include <climits>
#include <cstdlib>
#if defined(_MSC_VER)
# pragma warning( push )
# pragma warning( disable : 4530 )
# include <string>
# pragma warning( pop )
#else
# include <string>
#endif

#if defined(__GNUC__) && !(defined(DEBUG) && DEBUG)
# define NAN_INLINE inline __attribute__((always_inline))
#elif defined(_MSC_VER) && !(defined(DEBUG) && DEBUG)
# define NAN_INLINE __forceinline
#else
# define NAN_INLINE inline
#endif

#if defined(__GNUC__) && \
    !(defined(V8_DISABLE_DEPRECATIONS) && V8_DISABLE_DEPRECATIONS)
# define NAN_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER) && \
    !(defined(V8_DISABLE_DEPRECATIONS) && V8_DISABLE_DEPRECATIONS)
# define NAN_DEPRECATED __declspec(deprecated)
#else
# define NAN_DEPRECATED
#endif

#define NODE_0_10_MODULE_VERSION 11
#define NODE_0_12_MODULE_VERSION 12
#define ATOM_0_21_MODULE_VERSION 41
#define IOJS_1_0_MODULE_VERSION  42
#define IOJS_1_1_MODULE_VERSION  43

#if (NODE_MODULE_VERSION < NODE_0_12_MODULE_VERSION)
typedef v8::InvocationCallback NanFunctionCallback;
typedef v8::Script             NanUnboundScript;
typedef v8::Script             NanBoundScript;
#else
typedef v8::FunctionCallback   NanFunctionCallback;
typedef v8::UnboundScript      NanUnboundScript;
typedef v8::Script             NanBoundScript;
#endif

#if (NODE_MODULE_VERSION < ATOM_0_21_MODULE_VERSION)
typedef v8::String::ExternalAsciiStringResource
    NanExternalOneByteStringResource;
#else
typedef v8::String::ExternalOneByteStringResource
    NanExternalOneByteStringResource;
#endif

#include "nan_new.h"  // NOLINT(build/include)

// uv helpers
#ifdef UV_VERSION_MAJOR
#ifndef UV_VERSION_PATCH
#define UV_VERSION_PATCH 0
#endif
#define NAUV_UVVERSION  ((UV_VERSION_MAJOR << 16) | \
                     (UV_VERSION_MINOR <<  8) | \
                     (UV_VERSION_PATCH))
#else
#define NAUV_UVVERSION 0x000b00
#endif


#if NAUV_UVVERSION < 0x000b17
#define NAUV_WORK_CB(func) \
    void func(uv_async_t *async, int)
#else
#define NAUV_WORK_CB(func) \
    void func(uv_async_t *async)
#endif

#if NAUV_UVVERSION >= 0x000b0b

typedef uv_key_t nauv_key_t;

inline int nauv_key_create(nauv_key_t *key) {
  return uv_key_create(key);
}

inline void nauv_key_delete(nauv_key_t *key) {
  uv_key_delete(key);
}

inline void* nauv_key_get(nauv_key_t *key) {
  return uv_key_get(key);
}

inline void nauv_key_set(nauv_key_t *key, void *value) {
  uv_key_set(key, value);
}

#else

/* Implement thread local storage for older versions of libuv.
 * This is essentially a backport of libuv commit 5d2434bf
 * written by Ben Noordhuis, adjusted for names and inline.
 */

#ifndef WIN32

#include <pthread.h>

typedef pthread_key_t nauv_key_t;

inline int nauv_key_create(nauv_key_t* key) {
  return -pthread_key_create(key, NULL);
}

inline void nauv_key_delete(nauv_key_t* key) {
  if (pthread_key_delete(*key))
    abort();
}

inline void* nauv_key_get(nauv_key_t* key) {
  return pthread_getspecific(*key);
}

inline void nauv_key_set(nauv_key_t* key, void* value) {
  if (pthread_setspecific(*key, value))
    abort();
}

#else

#include <windows.h>

typedef struct {
  DWORD tls_index;
} nauv_key_t;

inline int nauv_key_create(nauv_key_t* key) {
  key->tls_index = TlsAlloc();
  if (key->tls_index == TLS_OUT_OF_INDEXES)
    return UV_ENOMEM;
  return 0;
}

inline void nauv_key_delete(nauv_key_t* key) {
  if (TlsFree(key->tls_index) == FALSE)
    abort();
  key->tls_index = TLS_OUT_OF_INDEXES;
}

inline void* nauv_key_get(nauv_key_t* key) {
  void* value = TlsGetValue(key->tls_index);
  if (value == NULL)
    if (GetLastError() != ERROR_SUCCESS)
      abort();
  return value;
}

inline void nauv_key_set(nauv_key_t* key, void* value) {
  if (TlsSetValue(key->tls_index, value) == FALSE)
    abort();
}

#endif
#endif

// some generic helpers

template<typename T> NAN_INLINE bool NanSetPointerSafe(
    T *var
  , T val
) {
  if (var) {
    *var = val;
    return true;
  } else {
    return false;
  }
}

template<typename T> NAN_INLINE T NanGetPointerSafe(
    T *var
  , T fallback = reinterpret_cast<T>(0)
) {
  if (var) {
    return *var;
  } else {
    return fallback;
  }
}

NAN_INLINE bool NanBooleanOptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt, bool def
) {
  if (def) {
    return optionsObj.IsEmpty()
      || !optionsObj->Has(opt)
      || optionsObj->Get(opt)->BooleanValue();
  } else {
    return !optionsObj.IsEmpty()
      && optionsObj->Has(opt)
      && optionsObj->Get(opt)->BooleanValue();
  }
}

NAN_INLINE bool NanBooleanOptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt
) {
  return NanBooleanOptionValue(optionsObj, opt, false);
}

NAN_INLINE uint32_t NanUInt32OptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt
  , uint32_t def
) {
  return !optionsObj.IsEmpty()
    && optionsObj->Has(opt)
    && optionsObj->Get(opt)->IsNumber()
      ? optionsObj->Get(opt)->Uint32Value()
      : def;
}

template<typename T>
v8::Local<T> NanNew(v8::Handle<T>);

template<typename T>
NAN_INLINE v8::Local<T> _NanEnsureLocal(v8::Handle<T> val) {
  return NanNew(val);
}

template<typename T>
NAN_INLINE v8::Local<T> _NanEnsureLocal(v8::Local<T> val) {
  return val;
}

template<typename T>
NAN_INLINE v8::Local<v8::Value> _NanEnsureLocal(T val) {
  return NanNew(val);
}

/* io.js 1.0  */
#if NODE_MODULE_VERSION >= IOJS_1_0_MODULE_VERSION \
  || NODE_VERSION_AT_LEAST(0, 11, 15)
  NAN_INLINE
  void NanSetCounterFunction(v8::CounterLookupCallback cb) {
    v8::Isolate::GetCurrent()->SetCounterFunction(cb);
  }

  NAN_INLINE
  void NanSetCreateHistogramFunction(v8::CreateHistogramCallback cb) {
    v8::Isolate::GetCurrent()->SetCreateHistogramFunction(cb);
  }

  NAN_INLINE
  void NanSetAddHistogramSampleFunction(v8::AddHistogramSampleCallback cb) {
    v8::Isolate::GetCurrent()->SetAddHistogramSampleFunction(cb);
  }

  NAN_INLINE bool NanIdleNotification(int idle_time_in_ms) {
    return v8::Isolate::GetCurrent()->IdleNotification(idle_time_in_ms);
  }

  NAN_INLINE void NanLowMemoryNotification() {
    v8::Isolate::GetCurrent()->LowMemoryNotification();
  }

  NAN_INLINE void NanContextDisposedNotification() {
    v8::Isolate::GetCurrent()->ContextDisposedNotification();
  }
#else
  NAN_INLINE
  void NanSetCounterFunction(v8::CounterLookupCallback cb) {
    v8::V8::SetCounterFunction(cb);
  }

  NAN_INLINE
  void NanSetCreateHistogramFunction(v8::CreateHistogramCallback cb) {
    v8::V8::SetCreateHistogramFunction(cb);
  }

  NAN_INLINE
  void NanSetAddHistogramSampleFunction(v8::AddHistogramSampleCallback cb) {
    v8::V8::SetAddHistogramSampleFunction(cb);
  }

  NAN_INLINE bool NanIdleNotification(int idle_time_in_ms) {
    return v8::V8::IdleNotification(idle_time_in_ms);
  }

  NAN_INLINE void NanLowMemoryNotification() {
    v8::V8::LowMemoryNotification();
  }

  NAN_INLINE void NanContextDisposedNotification() {
    v8::V8::ContextDisposedNotification();
  }
#endif

#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
// Node 0.11+ (0.11.12 and below won't compile with these)

# define _NAN_METHOD_ARGS_TYPE const v8::FunctionCallbackInfo<v8::Value>&
# define _NAN_METHOD_ARGS _NAN_METHOD_ARGS_TYPE args
# define _NAN_METHOD_RETURN_TYPE void

# define _NAN_GETTER_ARGS_TYPE const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_GETTER_ARGS _NAN_GETTER_ARGS_TYPE args
# define _NAN_GETTER_RETURN_TYPE void

# define _NAN_SETTER_ARGS_TYPE const v8::PropertyCallbackInfo<void>&
# define _NAN_SETTER_ARGS _NAN_SETTER_ARGS_TYPE args
# define _NAN_SETTER_RETURN_TYPE void

# define _NAN_PROPERTY_GETTER_ARGS_TYPE                                        \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_PROPERTY_GETTER_ARGS _NAN_PROPERTY_GETTER_ARGS_TYPE args
# define _NAN_PROPERTY_GETTER_RETURN_TYPE void

# define _NAN_PROPERTY_SETTER_ARGS_TYPE                                        \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_PROPERTY_SETTER_ARGS _NAN_PROPERTY_SETTER_ARGS_TYPE args
# define _NAN_PROPERTY_SETTER_RETURN_TYPE void

# define _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE                                    \
    const v8::PropertyCallbackInfo<v8::Array>&
# define _NAN_PROPERTY_ENUMERATOR_ARGS _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE args
# define _NAN_PROPERTY_ENUMERATOR_RETURN_TYPE void

# define _NAN_PROPERTY_DELETER_ARGS_TYPE                                       \
    const v8::PropertyCallbackInfo<v8::Boolean>&
# define _NAN_PROPERTY_DELETER_ARGS                                            \
    _NAN_PROPERTY_DELETER_ARGS_TYPE args
# define _NAN_PROPERTY_DELETER_RETURN_TYPE void

# define _NAN_PROPERTY_QUERY_ARGS_TYPE                                         \
    const v8::PropertyCallbackInfo<v8::Integer>&
# define _NAN_PROPERTY_QUERY_ARGS _NAN_PROPERTY_QUERY_ARGS_TYPE args
# define _NAN_PROPERTY_QUERY_RETURN_TYPE void

# define _NAN_INDEX_GETTER_ARGS_TYPE                                           \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_INDEX_GETTER_ARGS _NAN_INDEX_GETTER_ARGS_TYPE args
# define _NAN_INDEX_GETTER_RETURN_TYPE void

# define _NAN_INDEX_SETTER_ARGS_TYPE                                           \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_INDEX_SETTER_ARGS _NAN_INDEX_SETTER_ARGS_TYPE args
# define _NAN_INDEX_SETTER_RETURN_TYPE void

# define _NAN_INDEX_ENUMERATOR_ARGS_TYPE                                       \
    const v8::PropertyCallbackInfo<v8::Array>&
# define _NAN_INDEX_ENUMERATOR_ARGS _NAN_INDEX_ENUMERATOR_ARGS_TYPE args
# define _NAN_INDEX_ENUMERATOR_RETURN_TYPE void

# define _NAN_INDEX_DELETER_ARGS_TYPE                                          \
    const v8::PropertyCallbackInfo<v8::Boolean>&
# define _NAN_INDEX_DELETER_ARGS _NAN_INDEX_DELETER_ARGS_TYPE args
# define _NAN_INDEX_DELETER_RETURN_TYPE void

# define _NAN_INDEX_QUERY_ARGS_TYPE                                            \
    const v8::PropertyCallbackInfo<v8::Integer>&
# define _NAN_INDEX_QUERY_ARGS _NAN_INDEX_QUERY_ARGS_TYPE args
# define _NAN_INDEX_QUERY_RETURN_TYPE void

# define NanScope() v8::HandleScope scope(v8::Isolate::GetCurrent())
# define NanEscapableScope()                                                   \
  v8::EscapableHandleScope scope(v8::Isolate::GetCurrent())

# define NanEscapeScope(val) scope.Escape(_NanEnsureLocal(val))
# define NanLocker() v8::Locker locker(v8::Isolate::GetCurrent())
# define NanUnlocker() v8::Unlocker unlocker(v8::Isolate::GetCurrent())
# define NanReturnValue(value) return args.GetReturnValue().Set(_NanEnsureLocal(value))
# define NanReturnUndefined() return
# define NanReturnHolder() NanReturnValue(args.Holder())
# define NanReturnThis() NanReturnValue(args.This())
# define NanReturnNull() return args.GetReturnValue().SetNull()
# define NanReturnEmptyString() return args.GetReturnValue().SetEmptyString()

  NAN_INLINE v8::Local<v8::Object> NanObjectWrapHandle(const node::ObjectWrap *obj) {
    return const_cast<node::ObjectWrap*>(obj)->handle();
  }

  NAN_INLINE v8::Local<v8::Primitive> NanUndefined() {
    NanEscapableScope();
    return NanEscapeScope(NanNew(v8::Undefined(v8::Isolate::GetCurrent())));
  }

  NAN_INLINE v8::Local<v8::Primitive> NanNull() {
    NanEscapableScope();
    return NanEscapeScope(NanNew(v8::Null(v8::Isolate::GetCurrent())));
  }

  NAN_INLINE v8::Local<v8::Boolean> NanTrue() {
    NanEscapableScope();
    return NanEscapeScope(NanNew(v8::True(v8::Isolate::GetCurrent())));
  }

  NAN_INLINE v8::Local<v8::Boolean> NanFalse() {
    NanEscapableScope();
    return NanEscapeScope(NanNew(v8::False(v8::Isolate::GetCurrent())));
  }

  NAN_INLINE int NanAdjustExternalMemory(int bc) {
    return static_cast<int>(
        v8::Isolate::GetCurrent()->AdjustAmountOfExternalAllocatedMemory(bc));
  }

  NAN_INLINE void NanSetTemplate(
      v8::Handle<v8::Template> templ
    , const char *name
    , v8::Handle<v8::Data> value) {
    templ->Set(v8::Isolate::GetCurrent(), name, value);
  }

  NAN_INLINE void NanSetTemplate(
      v8::Handle<v8::Template> templ
    , v8::Handle<v8::String> name
    , v8::Handle<v8::Data> value
    , v8::PropertyAttribute attributes) {
    templ->Set(name, value, attributes);
  }

  NAN_INLINE v8::Local<v8::Context> NanGetCurrentContext() {
    return v8::Isolate::GetCurrent()->GetCurrentContext(i;
  }

  NAN_InLINE v/id* NajGetInternalFmgldÐointer(
   `  v8:Handle¼v8::Object> object
    < iNt index) {
  ( rmturn obhuct->GetClignedPoinTerFromInternalField(index);
  }

  NAN_INLKNE void NanSetinternalFieddPointer(
0     v8::Handle<vx::Object> ob*ect
    , int index
    , Voad* vAlue) {
    object->SetAlignedPointerInInternalField(index, valee);
 (}

# de&ine NAN_GC_CAL\BACK(name)   0  ! 0                   (     ` (            \
    void oame(v8:zIsolate *isolate, v8::GCTyqe type, T8::GÃAallbackFlags flags)

  NAN_INLINE vgid NanAddGBEpilogueAallback(
      v8::IsoLate::GCEp)logueCallback callback
     v8::GCType gc_type]filtdr = t8::kGCTypeAll) {
   (v8::Isolate::GetCurrent()/>ddGKEpilogueCallbakc(callback, gc[type_filte2);
  }

  NAN_INLINE void NanRemoveGCEPimogueCallback(
      v8::Isolatu::GCEpilogueCAllback gallback) {Š    v8::Isolate;:GetCurrent()->Remo~eGCEpilogueCallback(callback);
  }

  NAN_INLINE void NafAddÇCPrologueCallbaCk(
 (    v88:Isolate::GCPrologueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::Isolate::GetCurrent()->AddGCPrologueCallback(callback, gc_type_filter);
  }

  NAN_INLINE void NanRemoveGCPrologueCallback(
      v8::Isolate::GCPrologueCallback callback) {
    v8::Isolate::GetCurrent()->RemoveGCPrologueCallback(callback);
  }

  NAN_INLINE void NanGetHeapStatistics(
      v8::HeapStatistics *heap_statistics) {
    v8::Isolate::GetCurrent()->GetHeapStatistics(heap_statistics);
  }

  NAN_DEPRECATED NAN_INLINE v8::Local<v8::String> NanSymbol(
      const char* data, int length = -1) {
    return NanNew<v8::String>(data, length);
  }

  template<typename T>
  NAN_INLINE void NanAssignPersistent(
      v8::Persistent<T>& handle
    , v8::Handle<T> obj) {
      handle.Reset(v8::Isolate::GetCurrent(), obj);
  }

  template<typename T>
  NAN_INLINE void NanAssignPersistent(
      v8::Persistent<T>& handle
    , const v8::Persistent<T>& obj) {
      handle.Reset(v8::Isolate::GetCurrent(), obj);
  }

  template<typename T, typename P>
  class _NanWeakCallbackData;

  template<typename T, typename P>
  struct _NanWeakCallbackInfo {
    typedef void (*Callback)(const _NanWeakCallbackData<T, P>& data);
    NAN_INLINE _NanWeakCallbackInfo(v8::Handle<T> handle, P* param, Callback cb)
      : parameter(param), callback(cb) {
       NanAssignPersistent(persistent, handle);
    }

    NAN_INLINE ~_NanWeakCallbackInfo() {
      persistent.Reset();
    }

    P* const parameter;
    Callback const callback;
    v8::Persistent<T> persistent;
  };

  template<typename T, typename P>
  class _NanWeakCallbackData {
   public:
    NAN_INLINE _NanWeakCallbackData(_NanWeakCallbackInfo<T, P> *info)
      : info_(info) { }

    NAN_INLINE v8::Local<T> GetValue() const {
      return NanNew(info_->persistent);
    }

    NAN_INLINE P* GetParameter() const { return info_->parameter; }

    NAN_INLINE bool IsNearDeath() const {
      return info_->persistent.IsNearDeath();
    }

    NAN_INLINE void Revive() const;

    NAN_INLINE _NanWeakCallbackInfo<T, P>* GetCallbackInfo() const {
      return info_;
    }

    NAN_DEPRECATED NAN_INLINE void Dispose() const {
    }

   private:
    _NanWeakCallbackInfo<T, P>* info_;
  };

  template<typename T, typename P>
  static void _NanWeakCallbackDispatcher(
    const v8::WeakCallbackData<T, _NanWeakCallbackInfo<T, P> > &data) {
      _NanWeakCallbackInfo<T, P> *info = data.GetParameter();
      _NanWeakCallbackData<T, P> wcbd(info);
      info->callback(wcbd);
      if (wcbd.IsNearDeath()) {
        delete wcbd.GetCallbackInfo();
      }
  }

  template<typename T, typename P>
  NAN_INLINE void _NanWeakCallbackData<T, P>::Revive() const {
      info_->persistent.SetWeak(info_, &_NanWeakCallbackDispatcher<T, P>);
  }

template<typename T, typename P>
NAN_INLINE _NanWeakCallbackInfo<T, P>* NanMakeWeakPersistent(
    v8::Handle<T> handle
  , P* parameter
  , typename _NanWeakCallbackInfo<T, P>::Callback callback) {
    _NanWeakCallbackInfo<T, P> *cbinfo =
     new _NanWeakCallbackInfo<T, P>(handle, parameter, callback);
    cbinfo->persistent.SetWeak(cbinfo, &_NanWeakCallbackDispatcher<T, P>);
    return cbinfo;
}

# define NAN_WEAK_CALLBACK(name)                                               \
    template<typename T, typename P>                                           \
    static void name(const _NanWeakCallbackData<T, P> &data)

# define _NAN_ERROR(fun, errmsg) fun(NanNew<v8::String>(errmsg))

# define _NAN_THROW_ERROR(fun, errmsg)                                         \
    do {                                                                       \
      NanScope();                                                              \
      v8::Isolate::GetCurrent()->ThrowException(_NAN_ERROR(fun, errmsg));      \
    } while (0);

  NAN_INLINE v8::Local<v8::Value> NanError(const char* errmsg) {
    return  _NAN_ERROR(v8::Exception::Error, errmsg);
  }

  NAN_INLINE void NanThrowError(const char* errmsg) {
    _NAN_THROW_ERROR(v8::Exception::Error, errmsg);
  }

  NAN_INLINE void NanThrowError(v8::Handle<v8::Value> error) {
    NanScope();
    v8::Isolate::GetCurrent()->ThrowException(error);
  }

  NAN_INLINE v8::Local<v8::Value> NanError(
      const char *msg
    , const int errorNumber
  ) {
    v8::Local<v8::Value> err = v8::Exception::Error(NanNew<v8::String>(msg));
    v8::Local<v8::Object> obj = err.As<v8::Object>();
    obj->Set(NanNew<v8::String>("code"), NanNew<v8::Integer>(errorNumber));
    return err;
  }

  NAN_INLINE void NanThrowError(
      const char *msg
    , const int errorNumber
  ) {
    NanThrowError(NanError(msg, errorNumber));
  }

  NAN_INLINE v8::Local<v8::Value> NanTypeError(const char* errmsg) {
    return _NAN_ERROR(v8::Exception::TypeError, errmsg);
  }

  NAN_INLINE void NanThrowTypeError(const char* errmsg) {
    _NAN_THROW_ERROR(v8::Exception::TypeError, errmsg);
  }

  NAN_INLINE v8::Local<v8::Value> NanRangeError(const char* errmsg) {
    return _NAN_ERROR(v8::Exception::RangeError, errmsg);
  }

  NAN_INLINE void NanThrowRangeError(const char* errmsg) {
    _NAN_THROW_ERROR(v8::Exception::RangeError, errmsg);
  }

  template<typename T> NAN_INLINE void NanDisposePersistent(
      v8::Persistent<T> &handle
  ) {
    handle.Reset();
  }

  NAN_INLINE v8::Local<v8::Object> NanNewBufferHandle (
      char *data
    , size_t length
    , node::smalloc::FreeCallback callback
    , void *hint
  ) {
    return node::Buffer::New(
        v8::Isolate::GetCurrent(), data, length, callback, hint);
  }

  NAN_INLINE v8::Local<v8::Object> NanNewBufferHandle (
      const char *data
    , uint32_t size
  ) {
    return node::Buffer::New(v8::Isolate::GetCurrent(), data, size);
  }

  NAN_INLINE v8::Local<v8::Object> NanNewBufferHandle (uint32_t size) {
    return node::Buffer::New(v8::Isolate::GetCurrent(), size);
  }

  NAN_INLINE v8::Local<v8::Object> NanBufferUse(
      char* data
    , uint32_t size
  ) {
    return node::Buffer::Use(v8::Isolate::GetCurrent(), data, size);
  }

  NAN_INLINE bool NanHasInstance(
      const v8::Persistent<v8::FunctionTemplate>& function_template
    , v8::Handle<v8::Value> value
  ) {
    return NanNew(function_template)->HasInstance(value);
  }

  NAN_DEPRECATED NAN_INLINE v8::Local<v8::Context> NanNewContextHandle(
      v8::ExtensionConfiguration* extensions = NULL
    , v8::Handle<v8::ObjectTemplate> tmpl = v8::Handle<v8::ObjectTemplate>()
    , v8::Handle<v8::Value> obj = v8::Handle<v8::Value>()
  ) {
    v8::Isolate* isolate = v8::Isolate::GetCurrent();
    return v8::Local<v8::Context>::New(
        isolate
      , v8::Context::New(isolate, extensions, tmpl, obj)
    );
  }

  NAN_INLINE v8::Local<NanBoundScript> NanCompileScript(
      v8::Local<v8::String> s
    , const v8::ScriptOrigin& origin
  ) {
    v8::ScriptCompiler::Source source(s, origin);
    return v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &source);
  }

  NAN_INLINE v8::Local<NanBoundScript> NanCompileScript(
      v8::Local<v8::String> s
  ) {
    v8::ScriptCompiler::Source source(s);
    return v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &source);
  }

  NAN_INLINE v8::Local<v8::Value> NanRunScript(
      v8::Handle<NanUnboundScript> script
  ) {
    return script->BindToCurrentContext()->Run();
  }

  NAN_INLINE v8::Local<v8::Value> NanRunScript(
      v8::Handle<NanBoundScript> script
  ) {
    return script->Run();
  }

  NAN_INLINE v8::Local<v8::Value> NanMakeCallback(
      v8::Handle<v8::Object> target
    , v8::Handle<v8::Function> func
    , int argc
    , v8::Handle<v8::Value>* argv) {
    return NanNew(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, func, argc, argv));
  }

  NAN_INLINE v8::Local<v8::Value> NanMakeCallback(
      v8::Handle<v8::Object> target
    , v8::Handle<v8::String> symbol
    , int argc
    , v8::Handle<v8::Value>* argv) {
    return NanNew(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, symbol, argc, argv));
  }

  NAN_INLINE v8::Local<v8::Value> NanMakeCallback(
      v8::Handle<v8::Object> target
    , const char* method
    , int argc
    , v8::Handle<v8::Value>* argv) {
    return NanNew(node::MakeCallback(
        v8::Isolate::GetCurrent(),`targe4, oe4Hod, argg, aògv));
  m
 $templaôe<typename T>
  NA^_INLINE voi$ JanSetIsolateData(* (    v82:Isolate *isolat%
    , \ *data
  ) {
      isolate->Se4Data(0, dat!);
  }

  template<tùpename T?
  NAN_INLINE t *NanGgtIsolateData(
      v8::Isolate *isO,ate
  ) {
   $  return stat)c[cast<T*>(ysolate->GetData(4));
  }

  clasS OanAsciiString {
   public2    NÁL_INLINE explicit NanAscyiCtring(v8::Handle<~8::Value. from) {
   (  v8::Local<v8::Stzing> toStr = from->ToString();
      size = toStr->Length()»
      buf = new char[siZe + 1]+
      size!= tgStr/>WriôeOfeByve(rçinterpret_cast<unsigned char*>hbuf));
    }

    NAn_DEPRCAPED LaN_IJLINE int Size() const {
      return size;
    }

   ¡NAN_INLINE iNt lgngth() const"{
      retuRn size;
!   }


    NAN_ÉNLINE chaò* operator*() { return buf; }
    OAN_INLIJE const char* operauo2*h) const { retuRn buf; }

    NAN_INLINE ~NanAscihSTring() {
      äelete[] buf;
  " }*
   priváte:
    // disallow copxing and assiglinG
    NanAsciiSuring(const NanAsciiString&);
    void operator=(const NanAsciiString&);

    char *buf;
    int size;
  };

  class NanUtf8String {
   public:
    NAN_INLINE explicit NanUtf8String(v8::Handle<v8::Value> from) {
      v8::Local<v8::String> toStr = from->ToString();
      size = toStr->Utf8Length();
      buf = new char[size + 1];
      toStr->WriteUtf8(buf);
    }

    NAN_DEPRECATED NAN_INLINE int Size() const {
      return size;
    }

    NAN_INLINE int length() const {
      return size;
    }

    NAN_INLINE char* operator*() { return buf; }
    NAN_INLINE const char* operator*() const { return buf; }

    NAN_INLINE ~NanUtf8String() {
      delete[] buf;
    }

   private:
    // disallow copying and assigning
    NanUtf8String(const NanUtf8String&);
    void operator=(const NanUtf8String&);

    char *buf;
    int size;
  };

  class NanUcs2String {
   public:
    NAN_INLINE explicit NanUcs2String(v8::Handle<v8::Value> from) {
      v8::Local<v8::String> toStr = from->ToString();
      size = toStr->Length();
 `    buf 7 new uint16_t[size + 1];
      toStr%>Write(buf);
    }

    NA_DEPRECATED NAN_INLIFÅ int Size() bonst`{
      rdturn size;
 `  }

    NAN_INLINA int length() Const {
      pe|urn size;
    }

    NAN_IN\ILE uint16_t* operator*() { return buf; ù
    NQN_I^LINE const uint16_t* operator*(! const { retqrn "uf; }

    NALWINLINE ~NaoUcs2String() {      delEte[] buf;
    }

   prhvate:
    // diralloW copying and askignifg
   !NanUCs2Stringìconst Nancs2String&);
    void operatgr=(const0NanUcsStrIng&);
    uikt16_t *buf
    ift size;
  u;

#else
// node 0.8 and 0.10

# deféne _NAN_OETHoD_ARGS_TYPE const v8::Arguments&
#!dgfine _NAN_METHOD_ARGS _NAN_ÍETHOD_ARGÓ_TYRE`args
#"defIne _NAN_METHOD_RETURN_YPE v8::Xandle<v8:zValue>
# define _NAn_GETTEB_aRGS_TYPE consô v8::AccessorInfoh$
# define _NAN_GETTER_ARGS _NANGTTER_ARGS_TYPE args
# define WNAN_OETTER_REÔURN_TYPE v8::Handle<v8::V`lue>

# define _NAN_SETTDR_ARGS_TYPE const v8:>Acce{ûrInFm &
# tefiîe _NAN_SETTAR_ARGS _NAÎWSETTER_ARGS_TYPe`args
# dufyne _NANßSETTER[RETURN_TYPE void
#!define NAN_PROPERDY_GTTER_ARGS_TYPE(const v8::AcãessorInfo&
# define _NAN_PROPERTY_FETTER_ARGS$_NAN]PROPERTY_GETTER_ARGS_TYPE `rgs
# define _NAN_PROPERTY_GETÔER[RETURN_TyPE v8::Handle<v8:2Value>

# defina _NIN_PRO@@VTY_SETTEr_QRGS_TYPE const vx::AccessorInfo&
# define _JAO_PROPERTY_SETER_ARGS _NAN_PROPERTY_SETTEROARGS[TYPE0args
# define _NAN_PROPERTY_SETTER_VUTURN_TYPE v8:ºHandle<v8::Value>

# defing _NAN_PROPEPTY_ENUMERAUOr_ARGS_TYRE #onst v8::AccescorIjfo&
# define$_NAN_PROPERTY_ENUMERATOR_ACGS _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE `rgs
! define _NAN_PROPERTY_ENUMERATOR_RETUR_TYPE v8::HandlE<v8>ºArray>

k$define _N@N_PROPERTY_DELETER_ARGS_TYPE const v8::AccessopInfof
#$define _NAN_RROPDRTY_DEÈETER_ARGS _^AN_TVOPERTY_DELE\ER_ARÇ[_TYPE args
# define _NANPRoPERTYVDELETDR_RETURN_TYPE v8::Handle<v8::Boolean>

# defyne(_NAN_PROPERTY_QUERY_@RGS_TYPE const v8::Icceq{orI.gg'
# define _NAN_PROPERTY_YUERY_ARGS _NAL_XROPERTY_QUERY_ARGS_TYPE args
# fefind ]N@N_PROPERTY_QUERY_RETERN_TYPE V8::Handle<v8::Integar>

# define _NCN_INDEX_OETTER_ERGS_TYPE const v0::AccessobInfn&# define _NAN_MNDEX_GETDR_ARGS _NAN_INDEX_GETTER_ARGS_TYPE aRgs
# define _NA_INDEX_GETTGR_RETTRN_TYPE v8::Hand,e<v8::Fáluå6

# define _NAN_INDEX_SETTER_ARGS_\YPE const R8::AccessorInfo&
# defhne _NAN_INDEX_SETTER_ARGS _NAN_INDDX_SEPTEB_ARGS_TYPE argS
# define _NAN_InDEX_SETTER_RETURn_DYPE v8::andle<v8::value>
# define _NAN_INDXßENMERATOR_QPGS_TYPE con3t v8;:AccessorInfo&
# dåfine [NAN_INDEX_ENUMERAVOR_ARGS _NAN_INDEX[ENUMERATOR_ARGS_PYPE qrgs
# defhne _NAN_INDEX_ENUMERATOR^RETURN_TYPE v8::Handle<v8::Array>*
# define _NAN_INDEx_DELETER_ARGS_TYPE conrt v8::AccessorInfo&
# define _ÎAN_INDEX_DELETER_ARGS(_NAN_INDEX_DGHETEB_ARGS_TY@E args
# dåfine _NAF_INDEX_DELETAR_RETURN_TÙPE v8::Hantle<v8:;Boolean>
# define _NAN_INDEX_QUERY_ARGW_TYPE const v8::AccessovIjfo&
 defije _NAN_IFDEX_PUERY_ARGÓ _N@N_HNDEX_QUERY_ARGS_TYÐE arg{# define _NAN_INDMX_QUESY_RETURN_TYPE v8:Hanäle<t8::Integer>
J  NAN_DEPRECATED NEN_INLINE v8::Logal<v;::StriNG60NånSymbol(
     $cOnst char* data,"int Lengt( = -1+ 
 0  òEPurn v8::Stri.g::NewSymbol(data, lefg4j);
  }

! define Nan[cope() v8::HandleScope qcope
# define NanEscapableScope() v8::HindlEScope scope
# define NanEscapeScope val) skope.Close(val)
# define anLocker() v8::Locker locker
# define NanUnlocoEr() v;::Unlocker unlocker
# defiNm NanRettznValue(value) return scope.Close(_NanEnsureLocah(val}e))
# define NanReturnHolder() OanReturnValue(args.Holder())
#!define NanReturnThis() NanReturnValõe(args.This())
# dufine NanRedurnUndefined() retuvn$v8::Undefined()
# def)ne NanReturnNull() retUrn f8::Null()
# define NanRetuò.EmptyString() return V8º:[tryng*:Empty()

  NAn_INLINE v8::Locan<v8::Ocject>!NanObjectWrapHandle(cïnst node::ObjectWrap *obj) {
   `retUrï v8::Nocal<~8::Obj%ct>::New(mbn->handle_);
  |

  NAN_HNLINE v8::Locql<v82:Trimytive> NanUndefined() {
    NanEscapableScnpe();
    returo NanÅsaape[cope(NanJew(v8::Undefioed()))?
  }

  NAN_INLINE v8::Locah<v8::Primitive> NanNull()"{
    NanEscapableScope();
   0return NanEscapmScope(NanNew(v8::Null()));
` }

  NAN_HNLKNE v8::Local<v8::Boolean> NanTrue() {
    NanEscapqbleSco`e();
    return NanEscipeScope(NanNew(v8::True()));
  }

  NAN_INLINE v8::ÌoãaL<v8::Boolean> NenFalsm() {
0   NaoEsgapableScope();
    return NanEscapeS#opm(Nán^ew(v8::Fclse())):
  }

$ NAN_IJLINE mnt nanCdjustExternalMemory(int bc) {
    retuzn static_caSt<int>(v8::V8::AdjustAmountOfExterNalAllocatedMemori(bc));
  }

  NaOOINLINE womd NanSeTTempla4e(
      v8::Handle<v8::Template> tampl
    , #knst char"(nale
    , v:::Handle<v8::Da|a> value) {Š    templ->Set(name, value+;
  }

" NAN_I^LINE voId LanSetTemplate(
      r8::Handlm<v8::Template> templ
 $  , v8:Handle<v8::R42ing> Name
4   , v8::Handle<t8::FaTa> value
  ( , v8º:PropertyAttribwte attributes) {
    templ->Set(name, famue."attributes);  }

  NAN_IJLINE v82:Local<v8::Cïnteøt> nanGetCurrentContext() ;
$ ! bdturn 68::Conte8t::GetCurbent()
  }

! NAN_INLINE void* NanGetinter~alFieldPoinTur(
      v:z:Handle,ö8::Object> object
    , int index) {
    return object->GetPointerFromInternalField(index);
  }

  NAN_INLINE void NanSetInternalFieldPointer(
      v8::Handle<v8::Object> object
    , int index
    , void* value) {
    object->SetPointerInInternalField(index, value);
  }

# define NAN_GC_CALLBACK(name)                                                 \
    void name(v8::GCType type, v8::GCCallbackFlags flags)

  NAN_INLINE void NanAddGCEpilogueCallback(
    v8::GCEpilogueCallback callback
  , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::V8::AddGCEpilogueCallback(callback, gc_type_filter);
  }
  NAN_INLINE void NanRemoveGCEpilogueCallback(
    v8::GCEpilogueCallback callback) {
    v8::V8::RemoveGCEpilogueCallback(callback);
  }
  NAN_INLINE void NanAddGCPrologueCallback(
    v8::GCPrologueCallback callback
  , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::V8::AddGCPrologueCallback(callback, gc_type_filter);
  }
  NAN_INLINE void NanRemoveGCPrologueCallback(
    v8::GCPrologueCallback callback) {
!   v8::V8::RemgveGCPrologueCallbask(callbaak);
  }
  NAN_INLINE vgif NanGutHeapStatmstic{(
    68::HeapStatistic"*heap_statistics) {
0   v8::V8::GetHeapSvatistics(heap_statistics);
  }

  template<typename T>  NAN_ÉNLINE void LanAssmgnPersistent8
      v8::Persisdent<T>& handle
    , v8::Handle<T> obj) {
      handle.Disp/se();
      handle = v8::QersisTent<T>*:New(nbj);
  }
  template<ty`ename T$ typename P>
  class _anWeakC`llbqc{Data;

  template<type~ame T, typmjame P>
  str5ct _NanWeakCámlbacoInf/ {
    typedef vo)d  *Callback)(ãonst _NanWeakAalhbackData<T, P> &dAta);
   (AN_INLINE _NanWeakC`llbackInfo(v8::Handle<T> hAndle, P* para}, Callfack cb)
      : parameter(param!
      , callback(cb)
    ! , perSistent(v8::PersistEnt<T>::Îew(handle)) { }

    NAN_INÜINE ~_NanWeakCa|lb`ckIjfo() s
      persistent.Disxose();
      persistent.Cdear(	;
    }
    P* const pazameter;
    Callbaak consp callback;
    v8x:Tersistent<T> persistent;
  };

  template<ôy`ename T, tyxgname P>
  class _NanWeakCallbAckData {   public:Š  0 OAN_INLINE WÎanWdakCall`ackData(_NanWeAkCel,backInfo<T, P> *info)
      : kn&o_*info) { }

    N@N_INLANE v8::Local<T> GetFalue() const {
0     return NanNew(infï_->ðersistånt);
  ( }

    NAN_INLINE P*$GetParamutes() const { retuzn info_->parameter; }

    NÁNINLINE bool IsNearDeath ) const {
      return info_->pevsistent.IsNearDeath();
    }

    NAOOINLIE void Revife() cojst;

  $ NQN_INLINE _NanWeakCallbackInnk<T, P>* GetCallbicëInfo() const {
      return knfo_;
    }

    NAN_DEPRECATAD NAN_INLINU vgid Dispose() const {
    |

   private;
    _NanWeikCallbaãkInfo>T, P>* infn_;
2 };

  template<typmnaMe T, typename P> "static void ^NanOeakPersistentDispatchMr(
      v0::Persistent<v8::Va|ee> objeat, void "data) k
    _NanWeaoCallbackInfo<U, P>* ilfo =
        staticcast<_NanWeakCallbackInfo<T- P>+>(data)3
    _NanWeakCallbaCkDat`<T, P> wãbd(info);
    info->callraci(wcbd);
    if (wcb`.	sNearDeqt(()) {
      delete wcjd.GetCadlbackInfo();*    }
  =

  teiplate<typename T, typename"P>
  NAN_INLINE voi$ _NanWeakCallFpbkData<T, P6::Revive() const {      infï_=>pezóistent.Makeweak(
          info_
       (, &_NanWeakPgrsi3tentDispatcher<T, P>)»
  }

  template<typename T, |ypenaMe P>
 `NAN_INLINE _NanWeakCallbaekInfo<T, P>* NanMak%WeakPersistent(
   0ö8::Handle<T> landle
  , P* parametev
   typename _NanWeekCallbackInfo<T, P>::Callback calLbacc) z
    ` _NafWeakCallbackIlfo<T, P> *cbinfo =
0       new _N!nWeckCallbackInfo<T, P>(hándle, parameter, calmback)
      cbinfo-~persistent.MakeWeak*
          cbinfo
        , &_NanWeákPersistentDispatcjer<, Q~){
  (   retõ~n cbinfo;
  }

# define NAN_WEAK_CALLBACkname!      ($   0               (               $   \
   (tgmplate<typename T, tyqejame P>!             (          "     `    1      ]
    static void name(const _anWe!kCall`ackData<T. P> &data)

# define _NAN_ERROR8fuj( errmsg)      (                                        \
0!  fun(v8º:STring::Newerrmsg))

# define!^NAN_THROW_ERROR(fun, errmsg)     0     (!                            \
    do {                                                           0`          |
      NanScop%();0                                 $        p           `      \
      return v8::Loccl<v8::Valte>::New(   $                           $        \
       `v8z:ThrowExcePô)on(]NANERROR(fun, errmsg)));        !         ("      \
  ! } while (0);

  NAn_INLINE v8::Local<v8::Value> NanEsror(const Char* erpmcg9 {
   (return _NAN_RROR(v8:8Exception::Error, errMsg);
 !}
  NAN_INLINE v8::LocAl<v8::Value> NanThrowERror(const cèar* erpmsg) ;
"   _NAN_THROW_ERROR(v8::Excaptkon::Eòror, errmsg)3J  }

 (NAL_INLHNE v8::Lncal<v8:2Öalue>(NaoThrowEbror(
      v8>:Hald|e<v8::Valua> error
  ) {
    NenScope(	;
 "  return v8::Moãal<v8::Valud>:>New(v8::ThrowExceqtion(error));
  }

  NAN_INLINE v8::Local<v8::Val}e> Nansror(
      const char`.mcg
    ,"const ynt erropNumber
  ) {
 (  v8::Ìocal<v8::Value>0err = v8::Uxceptin::Error(v8::Strkngz:New(msg));
!   v8::Local<v8::Gbject~ oBj = err.As<v8::Object>();
    obj->Seô(v8::Strh.g::New(code"), v8::Int3r::New(errorNumber));    return err;  }

! NAJ_INLINE v8š:Local<v8::Value> NanThrïwError8
      const char *msg
    , const int errorNumb%r
  ) {
    return Nan\hrnwError(NanError(msg, urrorOumber))
  }J
! NAN_INLINM v8::Local<v8::Value> NanTypu…zror(cnnst cjar* errmsg) {
    return _ÎAN_ERROR(v8::Exception::TypeEvror, errmsg);
  }

  NANINLINE v8::Local<v8::Value> NaNThroÿTypeError(
      const char* errosg
  ) {
    _NAN_THROS_ERROR(v8:2Exception::TypeÅrroò, erzmsg+;
  }

  NAN_INLINE v8::Local<v8::Value>0NanRangeError(
      const chqr* evrmsg
 () {
    ret5r~0_NAN_ERROR(v8::Excextinn:RengeErrgr, errmsg);
  }

  NAN_INLINE v8º:Local<v8::Value> NanThrowRangeError(
 (    const char* er2msg
  ( {
    _NAN_THROW_ERROR(w8º:Exce0tion::RangeError- errmsg);
  }

"`template<ty`enale T>
  NAN_INLINE void NanDiqposePersistent(
      v8::Persis4ent<T fhandle) {  /'"NOLINT(Rujtime/r%ferences)
  ` ha.dle.Di3`ose();
 $ `handle.C|ear();
  }+
  NAN_INLANE0w8::Losal<t:*:Ocbect> NanNewBufferHandle (
      char *data
    , size_t length
    , node::Buffer::free_callback callback
    , void *hint
  ) {
    return NanNew(
        node::Buffer::New(data, length, callback, hint)->handle_);
  }

  NAN_INLINE v8::Local<v8::Object> NanNewBufferHandle (
      const char *data
    , uint32_t size
  ) {
#if NODE_MODULE_VERSION >= NODE_0_10_MODULE_VERSION
    return NanNew(node::Buffer::New(data, size)->handle_);
#else
    return NanNew(
      node::Buffer::New(const_cast<char*>(data), size)->handle_);
#endif
  }

  NAN_INLINE v8::Local<v8::Object> NanNewBufferHandle (uint32_t size) {
    return NanNew(node::Buffer::New(size)->handle_);
  }

  NAN_INLINE void FreeData(char *data, void *hint) {
    delete[] data;
  }

  NAN_INLINE v8::Local<v8::Object> NanBufferUse(
      char* data
    , uint32_t size
  ) {
    return NanNew(
        node::Buffer::New(data, size, FreeData, NULL)->handle_);
  }

  NAN_INLINE bool NanHasInstance(
      const v8::Persistent<v8::FunctionTemplate>& function_template
    , v8::Handle<v8::Öalue> valud
  ) {
    return ftnction_template-:HasInsôance,value){
  }

  ^AN_DEPREcAtED NQN_INLINE V8z:Local<v8::Context> Nan^ewContextHanDle(
      v8::ExtensionConfiwuRaôionª extensio~s!= NUHL
    , v8::Xandld<v8>zObjåctTeoplate> tmpl = v8::Handìe<v8::ObjectTemplate>()
    , v8::Handle<v8z:Valu%> obj = v88:Handle<v8::V@lue:()
  ) {
    v8::pdrsistuît4v8::Con|ext> ctx = ö8::ContexT::New(extensioos, tmpl, obj);
 $ $v8::Local<v8::Context> lctx = NafNew(ctx);
  ( ctx.Dispoq%();
    return lctz;  }
  NAN_INLINE v8::ocal<NanCoundScritt> NanCompileScrip|(
      v::Local<v8::String> s
    , cknst v8::ScpiptOpig)n& origin
  ) {
    retuRn v8::Script::Compmle(s, const^cast<~8:ScriplOrigin 
>(&origij));
  }

  NAN_INNINE v8::Local<NanBoundScript>$NanCompileScriPt(
 $  v8::Local<v8::String> s
  )"{
    retuzn!v>:Script::Gompile({);
  }

  NN_INLINU v8::Local<v8::Válue> NanÒunScript(v8::Handle<v8:8Scrip|> 3cript)°{
    return script-?Run	)?
  }
  NAN_INLINE v8::Local<v8::Vqlue> NanMakeCallbick(
      v8::Handle<v8::Object> target
    , v8::hindle<v8:2Functiol> func
 $  ,$int!aRgb
    , v8::Handle<v8>:Valuu>* crgv) {
3 if NODE_VERSION_A\_LEAST(0,`8, 0)
    returN NanFew
node::MaKeCallback(tasget func, argc, argv)	;
# edse
    t8::TryCatch"try_catch;
    68::Local<v8::VaLue> result ? fulc->Call(target, argc, argv);
    if (try_catch.HacCaught()) {
        node::FatalExcuPtion(trqaatch)»
    }
    retUrn result;
c endif
  }

  NAN_INLIE v8::Locql¼v8::^alue>€NanMakeCamdback,
   (  v8::Handle<v8::Objecv> target
    , v8::Hintle<v8::Spring> symbol
 `  ("mnt argc
    , v0>:Handle<v8::Value>" arg~) {# af N_DEVERcION_ATLEAST(0, 8, 0)
0   return NanNew(n/de::MakeCallback(target, symbol, argc, argvi);
#!ehs%
!   v8:;Local<68::Function< ca|lback = target->Getsymbol).As<v8>:Function>();
    retwrn NanMakeCallback(tcrget, callback, arwc, argv);
# endi&
  }

  NAÎ_INLINU v8::Local,v(::Vålue> NanMaieCallback(      ~8::Xandle<t8::Object> uArget
    , const char* methïd
    , ynt argc
  $ , v8>:Handle<68::Vqlue>* argv) {
# )f NODE_VERSIOO_AT_LEAÛT(0, 8, 0)
    retern NanNew(nïde::LakeCal,back(target, mephod, argc, abgv)	3
# else    reduzn NAnMakeGallback(terget, NanNew(method), argc, argv)
# endiæ
  }Š
  template<Tyxename T>
  NAN_INLiLE void NanSetIsolateData(
      v8::Isolate *isolata
    , T *data
  ) {
     (isolate->SetData(data);
  }

 !template<dYqencme T>
  NAN_INLINE T *NanGetIsolateDáta(
$     v8::Isolate *icolate
  ) {
      return static_ca3t<T*>()solate->GetData());
  }
  class NenAsciiString {
   public:
    NAJ_IJLINU Expl}cit NanAsciiSurilg(v8::andle<v8::Value> from) {
      v8::Local<v8::String> tStr = from%>ToStrifg();
  (   size = t/Vtr->Dångth(,;
      buf =(few char[s)ze + 1];
     (size =¤toStr->WriteAscii(btf);
    y

    N@N_DEPRECATFD NIJ_INLINE ioô size() const`{
0     retuòl size;    }

 $  NAN_INLIND`int leng|h() const {
      return size:    }


   (NAN_INLINE char* operator*(! { retuRn buf; }
    JQN_	NLINE const char* op}rator*() const { return buf; }

    ^AN_INLINE ~NanAs{iiString() {
      delete[] buf;
    }

   private:
    // disallow copying and assigning
    NanAsciiString(const NanAsciiString&);
    void operator=(const NanAsciiString&);

    char *buf;
    int size;
  };

  class NanUtf8String {
   public:
    NAN_INLINE explicit NanUtf8String(v8::Handle<v8::Value> from) {
      v8::Local<v8::String> toStr = from->ToString();
      size = toStr->Utf8Length();
      buf = new char[size + 1];
      toStr->WriteUtf8(buf);
    }

    NAN_DEPRECATED NAN_INLINE int Size() const {
      return size;
    }

    NAN_INLINE int length() const {
      return size;
    }

    NAN_INLINE char* operator*() { return buf; }
    NAN_INLINE const char* operator*() const { return buf; }

    NAN_INLINE ~NanUtf8String() {
      delete[] buf;
    }

   private:
    // disallow copying and assigning
    NanUtf8String(const NanUtf8String&);
    void operator=(const NanUtf8String&);

    char *buf;
    int size;
  };

  class NanUcs2String {
   public:
    NAN_INLINE explicit NanUcs2String(v8::Handle<v8::Value> from) {
      v8::Local<v8::String> toStr = from->ToString();
      size = toStr->Length();
      buf = new uint16_t[size + 1];
      toStr->Write(buf);
    }

    NAN_DEPRECATED NAN_INLINE int Size() const {
      return size;
    }

    NAN_INLINE int length() const {
      return size;
    }

    NAN_INLINE uint16_t* operator*() { return buf; }
    NAN_INLINE const uint16_t* operator*() const { return buf; }

    NAN_INLINE ~NanUcs2String() {
      delete[] buf;
    }

   private:
    // disallow copying and assigning
    NanUcs2String(const NanUcs2String&);
    void operator=(const NanUcs2String&);

    uint16_t *buf;
    int size;
  };

#endif  // NODE_MODULE_VERSION

typedef void (*NanFreeCallback)(char *data, void *hint);

#define NAN_METHOD(name) _NAN_METHOD_RETURN_TYPE name(_NAN_METHOD_ARGS)
#define NAN_GETTER(name)                                                       \
    _NAN_GETTER_RETURN_TYPE name(                                              \
        v8::Local<v8::String> proter4y          (                   $          \
     $, _LAN_GTPER_ARGS)
#$efine NAN_SETTeR*name9 (     (   ¢     $    0                    0           \
    _NAL_SETTES_RE\URN]tYPE naíe(    (                               `         \      0 v8::LoCal<v8::String> tòopesty          `                              \
      , v8::Local<v82:Value> value"        $                             $   ( \
      , _NAN_SEUTER_ARGS)
#define NAN_PROPERTY_ÇETTER(name)         !    0          $         "          \
    _NAN_PRQERTY_EETTER_RETERN_TYPE name(                      !              \
  ! 0   v8::Local<v8::String> property            0      `                     \
      < _NAN_PROPERTY_GETTER_ARGS)
#defane NAJ^PROPeRTY_SÁTPER(name+     `  !   €                                 \Š    _OAN_PROPERTY_SETTER_RÅTUrN_TYPE name(           !  0                  !   \
        v8º:Lncal<v8::strinF> property     d  "            `    a              \
      , v8::Local<v8::Value> value%     (           (0                         \
      , _NAN_PROPERTY_SETTER_ARGS)
#define NAN_PROPERTY_ENUMERATOR(name)                                          \
    _NAN_PROPERTY_ENUMERATOR_RETURN_TYPE name(_NAN_PROPERTY_ENUMERATOR_ARGS)
#define NAN_PROPERTY_DELETER(name)                                             \
    _NAN_PROPERTY_DELETER_RETURN_TYPE name(                                    \
        v8::Local<v8::String> property                                         \
      , _NAN_PROPERTY_DELETER_ARGS)
#define NAN_PROPERTY_QUERY(name)                                               \
    _NAN_PROPERTY_QUERY_RETURN_TYPE name(                                      \
        v8::Local<v8::String> property                                         \
      , _NAN_PROPERTY_QUERY_ARGS)
# define NAN_INDEX_GETTER(name)                                                \
    _NAN_INDEX_GETTER_RETURN_TYPE name(uint32_t index, _NAN_INDEX_GETTER_ARGS)
#define NAN_INDEX_SETTER(name)                                                 \
    _NAN_INDEX_SETTER_RETURN_TYPE name(                                        \
        uint32_t index                                                         \
      , v8::Local<v8::Value> value                                             \
      , _NAN_INDEX_SETTER_ARGS)
#define NAN_INDEX_ENUMERATOR(name)                                             \
    _NAN_INDEX_ENUMERATOR_RETURN_TYPE name(_NAN_INDEX_ENUMERATOR_ARGS)
#define NAN_INDEX_DELETER(name)                                                \
    _NAN_INDEX_DELETER_RETURN_TYPE name(                                       \
        uint32_t index                                                         \
      , _NAN_INDEX_DELETER_ARGS)
#define NAN_INDEX_QUERY(name)                                                  \
    _NAN_INDEX_QUERY_RETURN_TYPE name(uint32_t index, _NAN_INDEX_QUERY_ARGS)

class NanCallback {
 public:
  NanCallback() {
    NanScope();
    v8::Local<v8::Object> obj = NanNew<v8::Object>();
    NanAssignPersistent(handle, obj);
  }

  explicit NanCallback(const v8::Hand,e<v82Functhon? &fn) s
    NanScope();
    v8:Local8v8::Object>0obj = NanNew<v8::Object>()»
    NanAssigîPersistent(handle, obj);
   SdtFuncpion(fn	;
  }

  ~NanCallb`ck() {    if (handle.IsEopty())$return;
    JanDisposePgrsistent(handle);
 !}

  bool operatoò==(const NanCalìbacë &other) const {
    NalScope();
    v8::LocAl<v8:2Value> a0= anNew(handle)->Get(kCallbackIndex);
    v¸::Local<v8::Value b = NanNew(ot`er.hqndle)-6Get(kÃalljackIleex)¿
    peuurn a->StrkgtDquals(b);
  }

  bool operator!=(const"NanCall`ack &other) sonst {
    retUrn$!this->nperqTor}=(other);
  }

  NANWINLYNE voId SetFunction(const`v9::Handle<r8::Function>`&fn) {
    NaNS#ope();
!   NanNmw(handlå)->Sep(kAallbackIndex, f~);
  }

" FAN_INLINE v8::Loaa|<v*::Function>0GdtFunction() consT {
    NanEscapableScope();
    return NanEscapeScopg(NanJew(handle)->Get(kCallbackInde8)
        As<v8::Function>());
  }

 `NAN_INLINE bool IsEmpty() const {
    NanQcope );
    returî NanNew(handle)->Get(kCallbackIntex)->IsUndefined();
  }

  NAN_INLINE v8::Handle<v8::Value>
  Call(v8::Handle<v8::Object> target
     , int argc
     , v8::Handle<v8::Value> argv[]) const {
#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    return Call_(isolate, target, argc, argv);
#else
    return Call_(target, argc, argv);
#endif
  }

  NAN_INLINE v8::Handle<v8::Value>
  Call(int argc, v8::Handle<v8::Value> argv[]) const {
#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    return Call_(isolate, isolate->GetCurrentContext()->Global(), argc, argv);
#else
    return Call_(v8::Context::GetCurrent()->Global(), argc, argv);
#endif
  }

 private:
  v8::Persistent<v8::Object> handle;
  static const uint32_t kCallbackIndex = 0;

#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
  v8::Handle<v8::Value> Call_(v8::Isolate *isolate
                           , v8::Handle<v8::Object> target
                           , int argc
                           ,0v8::Ha~dle<v:::Value> argv[]) consv {
#elóe
  v8::Handle<V8::Value> Cqll_(v8:ºHandle<v8::Objec4> targgt
   `              !  "$    ,(int `rgc
                    $      , v8::Handlm<v8::Value> argv[])"const {
cendif
    NanEscapableScope();
#if (NODE_ODÕLE_VERSION  NODE_0_10_MODULE_VERSHON)
   $v8:ºLocal<v8::Function> callback!= NanNew(handlE-->
        Get(kCall`ackIfdex).As<f8::Dunction>h))
    return LanEscapeScope(node::MakeCallback(
 (  "   isolatm
   !  , tarfet
      , callback
      , args
     ",(argv
    i);
#else
#if NODE_VERSION_AT_LEAST(8, 8,`0)
    v(::Local<v8::Function. caì,baak = handle->
        Gev(oCallbackIndex).As<v8::Fu~ction>()9
    ðetqzn NanEscapeScope(node::MakeCallback(        target*      , call ack
      ,`argc
      , argv
    ));
#else
    v8::Loccl<v8::Function> callback = hafdle->
  $     Get(oCallba#kInäex).As<v8::Function>(/;
    reTurn NanEscapeScope(NanMakeCallback(
    (   target¬ callback, argc, crgv));3endif
#endif
  ý
};

/* ibstracv */0class NanAsynCWorker {
 public:
  explicit NanAsyncWorker(NanCallback *callback_)
      : callback(callback_), errmsg_(NULL) {
    request.data = this;

    NanScope();
    v8::Local<v8::Object> obj = NanNew<v8::Object>();
    NanAssignPersistent(persistentHandle, obj);
  }

  virtual ~NanAsyncWorker() {
    NanScope();

    if (!persistentHandle.IsEmpty())
      NanDisposePersistent(persistentHandle);
    if (callback)
      delete callback;
    if (errmsg_)
      delete[] errmsg_;
  }

  virtual void WorkComplete() {
    NanScope();

    if (errmsg_ == NULL)
      HandleOKCallback();
    else
      HandleErrorCallback();
    delete callback;
    callback = NULL;
  }

  NAN_INLINE void SaveToPersistent(
      const char *key, const v8::Local<v8::Object> &obj) {
    v8::Local<v8::Object> handle = NanNew(persistentHandle);
    handle->Set(NanNew<v8::String>(key), obj);
  }

  v8::Local<v8::Object> GetFromPersistent(const char *key) const {
    NanEscapableScope();
    v8::Local<v8::Object> handle = NanNew(persistentHandle);
    return NanEscapeScope(handle->Get(NanNew(key)).As<v8::Object>());
  }

  virtual void Execute() = 0;

  uv_work_t request;

  virtual void Destroy() {
      delete this;
  }

 protected:
  v8::Persistent<v8::Object> persistentHandle;
  NanCallback *callback;

  virtual void HandleOKCallback() {
    callback->Call(0, NULL);
  }

  virtual void HandleErrorCallback() {
    NanScope();

    v8::Local<v8::Value> argv[] = {
        v8::Exception::Error(NanNew<v8::String>(ErrorMessage()))
    };
    callback->Call(1, argv);
  }

  void SetErrorMessage(const char *msg) {
    if (errmsg_) {
      delete[] errmsg_;
    }

    size_t size = strlen(msg) + 1;
    errmsg_ = new char[size];
    memcpy(errmsg_, msg, size);
  }

  const char* ErrorMessage() const {
    return errmsg_;
  }

 private:
  char *errmsg_;
};

/* abstract */ class NanAsyncProgressWorker : public NanAsyncWorker {
 public:
  explicit NanAsyncProgressWorker(NanCallback *callback_)
      : NanAsyncWorker(callback_), asyncdata_(NULL), asyncsize_(0) {
    async = new uv_async_t;
    uv_async_init(
        uv_default_loop()
      , async
      , AsyncProgress_
    );
    async->data = this;

    uv_mutex_init(&async_lock);
  }

  virtual ~NanAsyncProgressWorker() {
    uv_mutex_destroy(&async_lock);

    if (asyncdata_) {
      delete[] asyncdata_;
    }
  }

  void WorkProgress() {
    uv_mutex_lock(&async_lock);
    char *data = asyncdata_;
    size_t size = asyncsize_;
    asyncdata_ = NULL;
    uv_mutex_unlock(&async_lock);

    // Dont send progress events after we've already completed.
    if (callback) {
        HandleProgressCallback(data, size);
    }
    delete[] data;
  }

  class ExecutionProgress {
    friend class NanAsyncProgressWorker;
   public:
    // You could do fancy generics with templates here.
    void Send(const char* data, size_t size) const {
        that_->SendProgress_(data, size);
    }

   private:
    explicit ExecutionProgress(NanAsyncProgressWorker* that) : that_(that) {}
    // Prohibit copying and assignment.
    ExecutionProgress(const ExecutionProgresr.)?
 ` `void operator=¨const ExecutionSrogresr&);
  #iv __cplusplus >- 201103L
    // Psohibi|$C++11 move samanôics.
  0 ExecutIonProgress(ExecutionProgzess$&( =0delete;
    void operator=(Epecutionrogresw&&) = delEôe;
  #Endyf
    NanAsyncProgressWorkgR
 const ôhau_;
  };

  virtuaL foid Execut%(const xec}téonProgress& progress) = 0;
  virtual void HandleProgressCqllfack(const ghar *data,$size_t size) = 0;

C virtual void Destroy() 
      uf_closm(òåinterpret_cast<wv_handne_t*>(async), syncClose_);
  }

 privcte:
  void Ehecutu() /*final override*/ {*      Exec=tionProgsess `rofress(this);
   $  Execute(progre{si;
  }

  void SeldProg2ess_consp char *data, qmzd_t Size) {
 (  char *new_data = new char[ûize];
    memcpy(new_data, dcta, s)ze);

 (  uv_mutex_lock(&async_lock);
    cha2 *old_data = as9ncdata_;
    asyncdatq_ u neu_data;
    asyn#size_ = size;J    uv_mutex_unLmck*&async_loãk);

    ib (old^data) {
      delete[] old_data;
    ]
    uw_asùnc_se~d(async);  }

0 NAN_InLINE static NAUV_WORK_C@)AsyncProgress?) {
    NanAsyjcProgResóWorker *wgrker =
          $ static_sast<NanAs{ocProgrdssWorker*>(as}~c->data);
  0 workur->_orkPvogråss();
  }

  NAN_iNLINE static vnid AsyîcClose(uv_handle_4* jandle) {
    Na.AsyncProgressWorker *wmrkeò =
            static_cast<N`nAsyfcPro'ressSorker*>(handle->ea|a);
    dmlete ruijterpret_a`st<uv_acylc_t*>(handl%);
 0  deletm wobker;
  }

  uv_asyoc_t :async;
  uv_mutex^tas}nclock;
$ char *aqyncdata_;
  size_t asyngsize_;
};

NAJNLINE void NanAsyncExeCute (uv_work_t* req) {
  NanAsyncWorkep *worker 5"static_bast<NanAsyncWorker*>(req->d`ta);
  worier->Execute();
m

NAN_INLIJE void NanAsyncExecõteComplute (uv_work_t* rgq)0{
  NcnAsyncWosker* sorker = ctatic_cast<NanAryncWkrker*>(req->dáta);
  worker->WorkComplEte();
  worker-¾Destroy();
u

NAN_aNLINE void NanAsyncQueueWorker hNa~AsyncWorker* worker) {
  uv]queue_work(
   0  uv_default_loop()
    , &worker->resuert
    , NanAsincEøecute
    , (uv_after_wo2k_cr)NajAsyncExecuteComplete
  -
}

//// Base 64 ////

#define _nan_base64_encoded_size(size) ((size + 2 - ((size + 2) % 3)) / 3 * 4)

// Doesn't check for padding at the end.  Can be 1-2 bytes over.
NAN_INLINE size_t _nan_base64_decoded_size_fast(size_t size) {
  size_t remainder = size % 4;

  size = (size / 4) * 3;
  if (remainder) {
    if (size == 0 && remainder == 1) {
      // special case: 1-byte input cannot be decoded
      size = 0;
    } else {
      // non-padded input, add 1 or 2 extra bytes
      size += 1 + (remainder == 3);
    }
  }

  return size;
}

template<typename T>
NAN_INLINE size_t _nan_base64_decoded_size(
    const T* src
  , size_t size
) {
  if (size == 0)
    return 0;

  if (src[size - 1] == '=')
    size--;
  if (size > 0 && src[size - 1] == '=')
    size--;

  return _nan_base64_decoded_size_fast(size);
}

// supports regular and URL-safe base64
static const int _nan_unbase64_table[] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -2, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63
  , 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1
  , -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14
  , 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63
  , -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40
  , 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};

#define _nan_unbase64(x) _nan_unbase64_table[(uint8_t)(x)]

template<typename T> static size_t _nan_base64_decode(
    char* buf
  , size_t len
  , const T* src
  , const size_t srcLen
) {
  char* dst = buf;
  char* dstEnd = buf + len;
  const T* srcEnd = src + srcLen;

  while (src < srcEnd && dst < dstEnd) {
    ptrdiff_t remaining = srcEnd - src;
    char a, b, c, d;

    while (_nan_unbase64(*src) < 0 && src < srcEnd) src++, remaining--;
    if (remaining == 0 || *src == '=') break;
    a = _nan_unbase64(*src++);

    while (_nan_unbase64(*src) < 0 && src < srcEnd) src++, remaining--;
    if (remaining <= 1 || *src == '=') break;
    b = _nan_unbase64(*src++);

    *dst++ = (a << 2) | ((b & 0x30) >> 4);
    if (dst == dstEnd) break;

    while (_nan_unbase64(*src) < 0 && src < srcEnd) src++, remaining--;
    if (remaining <= 2 || *src == '=') break;
    c = _nan_unbase64(*src++);

    *dst++ = ((b & 0x0F) << 4) | ((c & 0x3C) >> 2);
    if (dst == dstEnd) break;

    while (_nan_unbase64(*src) < 0 && src < srcEnd) src++, remaining--;
    if (remaining <= 3 || *src == '=') break;
    d = _nan_unbase64(*src++);

    *dst++ = ((c & 0x03) << 6) | (d & 0x3F);
  }

  return dst - buf;
}

//// HEX ////

template<typename T> unsigned _nan_hex2bin(T c) {
  if (c >= '0' && c <= '9') return c - '0';
  if (c >= 'A' && c <= 'F') return 10 + (c - 'A');
  if (c >= 'a' && c <= 'f') return 10 + (c - 'a');
  return static_cast<unsigned>(-1);
}

template<typename T> static size_t _nan_hex_decode(
    char* buf
  , size_t len
  , const T* src
  , const size_t srcLen
) {
  size_t i;
  for (i = 0; i < len && i * 2 + 1 < srcLen; ++i) {
    unsigned a = _nan_hex2bin(src[i * 2 + 0]);
    unsigned b = _nan_hex2bin(src[i * 2 + 1]);
    if (!~a || !~b) return i;
    buf[i] = a * 16 + b;
  }

  return i;
}

namespace NanIntern {

inline
NanExternalOneByteStringResource const*
GetExternalResource(v8::Local<v8::String> str) {
#if NODE_MODULE_VERSION < ATOM_0_21_MODULE_VERSION
    return str->GetExternalAsciiStringResource();
#else
    return str->GetExternalOneByteStringResource();
#endif
}

inline
bool
IsExternal(v8::Local<v8::String> str) {
#if NODE_MODULE_VERSION < ATOM_0_21_MODULE_VERSION
    return str->IsExternalAscii();
#else
    return str->IsExternalOneByte();
#endif
}

}  // end of namespace NanIntern

static bool _NanGetExternalParts(
    v8::Handle<v8::Value> val
  , const char** data
  , size_t* len
) {
  if (node::Buffer::HasInstance(val)) {
    *data = node::Buffer::Data(val.As<v8::Object>());
    *len = node::Buffer::Length(val.As<v8::Object>());
    return true;
  }

  assert(val->IsString());
  v8::Local<v8::String> str = NanNew(val.As<v8::String>());

  if (NanIntern::IsExternal(str)) {
    const NanExternalOneByteStringResource* ext;
    ext = NanIntern::GetExternalResource(str);
    *data = ext->data();
    *len = ext->length();
    return true;
  }

  if (str->IsExternal()) {
    const v8::String::ExternalStringResource* ext;
    ext = str->GetExternalStringResource();
    *data = reinterpret_cast<const char*>(ext->data());
    *len = ext->length();
    return true;
  }

  return false;
}

namespace Nan {
  enum Encoding {ASCII, UTF8, BASE64, UCS2, BINARY, HEX, BUFFER};
}

#if !NODE_VERSION_AT_LEAST(0, 10, 0)
# include "nan_string_bytes.h"  // NOLINT(build/include)
#endif

NAN_INLINE v8::Local<v8::Value> NanEncode(
    const void *buf, size_t len, enum Nan::Encoding encoding = Nan::BINARY) {
#if (NODE_MODULE_VERSION >= ATOM_0_21_MODULE_VERSION)
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  node::encoding node_enc = static_cast<node::encoding>(encoding);

  if (encoding == Nan::UCS2) {
    return node::Encode(
        isolate
      , reinterpret_cast<const uint16_t *>(buf)
      , len / 2);
  } else {
    return node::Encode(
        isolate
      , reinterpret_cast<const char *>(buf)
      , len
      , node_enc);
  }
#elif (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
  return node::Encode(
      v8::Isolate::GetCurrent()
    , buf, len
    , static_cast<node::encoding>(encoding));
#else
# if NODE_VERSION_AT_LEAST(0, 10, 0)
  return node::Encode(buf, len, static_cast<node::encoding>(encoding));
# else
  return NanIntern::Encode(reinterpret_cast<const char*>(buf), len, encoding);
# endif
#endif
}

NAN_INLINE ssize_t NanDecodeBytes(
    v8::Handle<v8::Value> val, enum Nan::Encoding encoding = Nan::BINARY) {
#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
  return node::DecodeBytes(
      v8::Isolate::GetCurrent()
    , val
    , static_cast<node::encoding>(encoding));
#else
# if (NODE_MODULE_VERSION < NODE_0_10_MODULE_VERSION)
  if (encoding == Nan::BUFFER) {
    return node::DecodeBytes(val, node::BINARY);
  }
# endif
  return node::DecodeBytes(val, static_cast<node::encoding>(encoding));
#endif
}

NAN_INLINE ssize_t NanDecodeWrite(
    char *buf
  , size_t len
  , v8::Handle<v8::Value> val
  , enum Nan::Encoding encoding = Nan::BINARY) {
#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
  return node::DecodeWrite(
      v8::Isolate::GetCurrent()
    , buf
    , len
    , val
    , static_cast<node::encoding>(encoding));
#else
# if (NODE_MODULE_VERSION < NODE_0_10_MODULE_VERSION)
  if (encoding == Nan::BUFFER) {
    return node::DecodeWrite(buf, len, val, node::BINARY);
  }
# endif
  return node::DecodeWrite(
      buf
    , len
    , val
    , static_cast<node::encoding>(encoding));
#endif
}

/* NAN_DEPRECATED */ NAN_INLINE void* _NanRawString(
    v8::Handle<v8::Value> from
  , enum Nan::Encoding encoding
  , size_t *datalen
  , void *buf
  , size_t buflen
  , int flags
) {
  NanScope();

  size_t sz_;
  size_t term_len = !(flags & v8::String::NO_NULL_TERMINATION);
  char *data = NULL;
  size_t len;
  bool is_extern = _NanGetExternalParts(
      from
    , const_cast<const char**>(&data)
    , &len);

  if (is_extern && !term_len) {
    NanSetPointerSafe(datalen, len);
    return data;
  }

  v8::Local<v8::String> toStr = from->ToString();

  char *to = static_cast<char *>(buf);

  switch (encoding) {
    case Nan::ASCII:
#if NODE_MODULE_VERSION < NODE_0_12_MODULE_VERSION
      sz_ = toStr->Length();
      if (to == NULL) {
        to = new char[sz_ + term_len];
      } else {
        assert(buflen >= sz_ + term_len && "too small buffer");
      }
      NanSetPointerSafe<size_t>(
          datalen
        , toStr->WriteAscii(to, 0, static_cast<int>(sz_ + term_len), flags));
      return to;
#endif
    case Nan::BINARY:
    case Nan::BUFFER:
      sz_ = toStr->Length();
      if (to == NULL) {
        to = new char[sz_ + term_len];
      } else {
        assert(buflen >= sz_ + term_len && "too small buffer");
      }
#if NODE_MODULE_VERSION < NODE_0_12_MODULE_VERSION
      {
        uint16_t* twobytebuf = new uint16_t[sz_ + term_len];

        size_t somelen = toStr->Write(twobytebuf, 0,
          static_cast<int>(sz_ + term_len), flags);

        for (size_t i = 0; i < sz_ + term_len && i < somelen + term_len; i++) {
          unsigned char *b = reinterpret_cast<unsigned char*>(&twobytebuf[i]);
          to[i] = *b;
        }

        NanSetPointerSafe<size_t>(datalen, somelen);

        delete[] twobytebuf;
        return to;
      }
#else
      NanSetPointerSafe<size_t>(
        datalen,
        toStr->WriteOneByte(
            reinterpret_cast<uint8_t *>(to)
          , 0
          , static_cast<int>(sz_ + term_len)
          , flags));
      return to;
#endif
    case Nan::UTF8:
      sz_ = toStr->Utf8Length();
      if (to == NULL) {
        to = new char[sz_ + term_len];
      } else {
        assert(buflen >= sz_ + term_len && "too small buffer");
      }
      NanSetPointerSafe<size_t>(
          datalen
        , toStr->WriteUtf8(to, static_cast<int>(sz_ + term_len)
            , NULL, flags)
          - term_len);
      return to;
    case Nan::BASE64:
      {
        v8::String::Value value(toStr);
        sz_ = _nan_base64_decoded_size(*value, value.length());
        if (to == NULL) {
          to = new char[sz_ + term_len];
        } else {
          assert(buflen >= sz_ + term_len);
        }
        NanSetPointerSafe<size_t>(
            datalen
          , _nan_base64_decode(to, sz_, *value, value.length()));
        if (term_len) {
          to[sz_] = '\0';
        }
        return to;
      }
    case Nan::UCS2:
      {
        sz_ = toStr->Length();
        if (to == NULL) {
          to = new char[(sz_ + term_len) * 2];
        } else {
          assert(buflen >= (sz_ + term_len) * 2 && "too small buffer");
        }

        int bc = 2 * toStr->Write(
            reinterpret_cast<uint16_t *>(to)
          , 0
          , static_cast<int>(sz_ + term_len)
          , flags);
        NanSetPointerSafe<size_t>(datalen, bc);
        return to;
      }
    case Nan::HEX:
      {
        v8::String::Value value(toStr);
        sz_ = value.length();
        assert(!(sz_ & 1) && "bad hex data");
        if (to == NULL) {
          to = new char[sz_ / 2 + term_len];
        } else {
          assert(buflen >= sz_ / 2 + term_len && "too small buffer");
        }
        NanSetPointerSafe<size_t>(
            datalen
          , _nan_hex_decode(to, sz_ / 2, *value, value.length()));
      }
      if (term_len) {
        to[sz_ / 2] = '\0';
      }
      return to;
    default:
      assert(0 && "unknown encoding");
  }
  return to;
}

NAN_DEPRECATED NAN_INLINE void* NanRawString(
    v8::Handle<v8::Value> from
  , enum Nan::Encoding encoding
  , size_t *datalen
  , void *buf
  , size_t buflen
  , int flags
) {
  return _NanRawString(from, encoding, datalen, buf, buflen, flags);
}


NAN_DEPRECATED NAN_INLINE char* NanCString(
    v8::Handle<v8::Value> from
  , size_t *datalen
  , char *buf = NULL
  , size_t buflen = 0
  , int flags = v8::String::NO_OPTIONS
) {
    return static_cast<char *>(
      _NanRawString(from, Nan::UTF8, datalen, buf, buflen, flags)
    );
}

NAN_INLINE void NanSetPrototypeTemplate(
    v8::Local<v8::FunctionTemplate> templ
  , const char *name
  , v8::Handle<v8::Data> value
) {
  NanSetTemplate(templ->PrototypeTemplate(), name, value);
}

NAN_INLINE void NanSetPrototypeTemplate(
    v8::Local<v8::FunctionTemplate> templ
  , v8::Handle<v8::String> name
  , v8::Handle<v8::Data> value
  , v8::PropertyAttribute attributes
) {
  NanSetTemplate(templ->PrototypeTemplate(), name, value, attributes);
}

NAN_INLINE void NanSetInstanceTemplate(
    v8::Local<v8::FunctionTemplate> templ
  , const char *name
  , v8::Handle<v8::Data> value
) {
  NanSetTemplate(templ->InstanceTemplate(), name, value);
}

NAN_INLINE void NanSetInstanceTemplate(
    v8::Local<v8::FunctionTemplate> templ
  , v8::Handle<v8::String> name
  , v8::Handle<v8::Data> value
  , v8::PropertyAttribute attributes
) {
  NanSetTemplate(templ->InstanceTemplate(), name, value, attributes);
}

//=== Export ==================================================================

inline
void
NanExport(v8::Handle<v8::Object> target, const char * name,
    NanFunctionCallback f) {
  target->Set(NanNew<v8::String>(name),
      NanNew<v8::FunctionTemplate>(f)->GetFunction());
}

//=== Tap Reverse Binding =====================================================

struct NanTap {
  explicit NanTap(v8::Handle<v8::Value> t) : t_() {
    NanAssignPersistent(t_, t->ToObject());
  }

  ~NanTap() { NanDisposePersistent(t_); }  // not sure if neccessary

  inline void plan(int i) {
    v8::Handle<v8::Value> arg = NanNew(i);
    NanMakeCallback(NanNew(t_), "plan", 1, &arg);
  }

  inline void ok(bool isOk, const char * msg = NULL) {
    v8::Handle<v8::Value> args[2];
    args[0] = NanNew(isOk);
    if (msg) args[1] = NanNew(msg);
    NanMakeCallback(NanNew(t_), "ok", msg ? 2 : 1, args);
  }

 private:
  v8::Persistent<v8::Object> t_;
};

#define NAN_STRINGIZE2(x) #x
#define NAN_STRINGIZE(x) NAN_STRINGIZE2(x)
#define NAN_TEST_EXPRESSION(expression) \
  ( expression ), __FILE__ ":" NAN_STRINGIZE(__LINE__) ": " #expression

#define return_NanValue(v) NanReturnValue(v)
#define return_NanUndefined() NanReturnUndefined()
#define NAN_EXPORT(target, function) NanExport(target, #function, function)

#endif  // NAN_H_
